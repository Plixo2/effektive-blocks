module main

/*
  Main entry and web page setup for the Wave Function Collapse demo.
*/

import src/lib/dom
import src/lib/canvas
import src/lib/color

import src/wfc/adjacency
import src/wfc/wfc2
import src/wfc/tile


/// Some default styling for the main elements
namespace Styling {
  def cell(node: Node) = node.css {
    property("border", "1px solid #ccccccff")
    property("box-sizing", "border-box")
    property("aspect-ratio", "1 / 1")
    property("position", "relative")
    
    property("display", "flex")
    property("align-items", "center")
    property("justify-content", "center")
  }

  def grid(node: Node, size: Int) = node.css {
    property("width", "min(calc(100% - (10px * 2)), calc(100vh - (10px * 2)))")
    property("aspect-ratio", "1 / 1")
    property("border", "2px solid #333333ff")
    property("display", "grid")
    property("grid-template-columns", s"repeat(${size.show}, 1fr)")
    property("grid-template-rows", s"repeat(${size.show}, 1fr)")
    property("box-sizing", "border-box")
  }

  def fullscreen(node: Node) = node.css { 
      property("margin", 0)
      property("padding", 0)
      property("height", "100%")
      property("width", "100%")
      property("overflow", "hidden")
      property("display", "flex")
      property("font-family", "'Segoe UI', system-ui, sans-serif")
  }

  def stateCell(node: Node, cellSize: Double, column: Int, row: Int) = node.css {
    property("position", "absolute")
    property("width", cellSize.show ++ "px")
    property("height", cellSize.show ++ "px")
    property("left", (row.toDouble * cellSize).show ++ "px")
    property("top", (column.toDouble * cellSize).show ++ "px")
  }

}

type StateDOMCells = Array[Node]

/// Create a grid of DOM elements to render the WFC state into
/// Each cell can contain multiple images when in manual mode
def createDOMCells(showCanvas: Node, size: Int): StateDOMCells = {
  val elements = array::unsafeAllocate(size * size)
  showCanvas.removeContent()
  showCanvas.onChildren {
    val container = div {
      each (0, size) { y =>
        each (0, size) { x =>
          val c = div{}
          Styling::cell(c)
          elements.set(y * size + x, c)
          ()
        }
      }
    };
    Styling::grid(container, size)
    ()
  }
  elements
}


/// update the WFC and render the current state. Either done automatically or manually via clicks
def render(manualMode: Bool, saveImage: Bool, delay: Int, cells: StateDOMCells, gridReference: Ref[StateGrid]): Unit = {
  val grid = gridReference.get()
  var size = grid.size
  
  each (0, size) { y =>
    each (0, size) { x =>
      if (manualMode) {
        var imgs = grid.tilesAt((x, y))
       
        var container = cells.get(y * size + x)
        var count = imgs.size().toDouble
        val n = count.sqrt().ceil() // calculate size of grid in grid cell
        val size = container.clientWidth.toDouble;   
        val cellSize = size / n.toDouble;   

        container.removeContent()
        imgs.foreachIndex { (i, tileIndex) => {
          var img = grid.tileset.tiles.get(tileIndex).htmlImage
          val item = img.clone; // clone image element
          val column = (i.toDouble / n.toDouble).floor;
          val row = (i.mod(n));
          Styling::stateCell(item, cellSize, column, row)

          //setup click handler to collapse cells
          item.onClick(box {
            with popup
            try {
              grid.collapseAtSpecific((x, y), tileIndex)
              grid.propagate((x, y))
              if (saveImage && grid.isCollapsed()) {
                val image = grid.createStateImageCollapsed()
                image.download("map2.png")
              }
              render(manualMode, saveImage, delay, cells, gridReference)
            } with fail { => 
              do Popup("Could not solve image, try increasing the size or changing the image/mask")
            }
          })
          container.appendChild(item)
          ()
        }}
      } else {
        var imgs = grid.getImages((x, y))
        if (imgs.size() == 1) {
          // collapse into a single image
          var container = cells.get(y * size + x)
          container.removeContent()
          container.appendChild(imgs.get(0).clone)
        }
      }
      ()
    }
  }

  if (not(manualMode)) {
    dom::wait(delay, box {
      with popup
      try {
        grid.step()
        render(manualMode, saveImage, delay, cells, gridReference)
      } with fail { => 
        do Popup("Could not solve image, try increasing the size or changing the image/mask")
      } with stop { => 
        if (saveImage) {
          val image = grid.createStateImageCollapsed()
          image.download("map1.png")
        }
      }
      ()
    })
  }
}

/// Reads all inputs and starts the WFC process
/// Note that this does all the error handling. 
/// Errors are handled each click, so the user can try again without reloading the page.
def createWFCContext(
  showCanvas: Node,     // main canvas to draw to
  color: Node,          // color image
  mask: Node,           // mask image
  size: Node,           // pixels per tile
  gridSizeNode: Node,   // size of the grid
  speedNode: Node,      // speed of the visualization
  drawNode: Node,       // whether to draw the process, or let the use click
  saveNode: Node,       // whether to save the result as png
  canContinue: => Bool at global
) at {io}: Unit = {

  with popup 

  val pixels       =    size.numberFromInputElement()
  val gridSize     =    gridSizeNode.numberFromInputElement()
  val speedPercent =    speedNode.numberFromInputElement().toDouble / 100.0
  val draw         =    drawNode.boolFromInputElement()
  val save         =    saveNode.boolFromInputElement()

  if (draw && gridSize > 16) {
    do Popup("Size to lange. Your browser does not support this. Disable drawing. ")
  }

  canvas::loadImageFromInputElement(color, box { color? => 
    canvas::loadImageFromInputElement(mask, box { mask? => 
      with popup

      val color: Image = color?.getOrElse {
        do Popup(s"Provide a color image")
      }
      val mask: Image = mask?.getOrElse {
        do Popup(s"Provide a mask image")
      }
      // first the layout of the color and mask image
      val imageLayout = createLayout(color, mask, pixels)
      // calculate ruleset from image data 
      val ruleset = createRuleset(color, mask, imageLayout)

      // calculate tileset to draw and work with
      val tileset = ruleset.calculateTileSet()

      val state = ref(wfcStateGrid(tileset, gridSize))

      //calculate the speed
      val maxWait = 1000
      val waitTime = (maxWait.toDouble * (1.0 - speedPercent)).max(0.0).toInt

      // create HMTL elements to render the state into
      var cells = createDOMCells(showCanvas, gridSize)
      render(not(draw), save, waitTime, cells, state)

      ()
    })
  })

}

/// Add a labeled input element (file/number/range)
def addInputGroup(name: String, inputElement: Node): Node / { HTMLElement } = {
  div {
    label(name).css {
      property("font-size", "0.85rem")
      property("font-weight", "600")
      property("color", "#a6adc8")
    }.attributes {
      attribute("for", name)
    }
    inputElement.insert.css {
      property("width", "100%")
      property("background", "#2b2b3b")
      property("border", "1px solid #2b2b31ff")
      property("color", "white")
      property("padding", "8px")
      property("border-radius", "6px")
      property("outline", "none")
      property("box-sizing", "border-box")
    }.attributes {
      attribute("id", name)
    }

    
  }.css {
    property("display", "flex")
    property("flex-direction", "column")
    property("gap", "5px")
    property("box-sizing", "border-box")
  }
  return inputElement
}
/// Add a checkbox input with label
def addCheckboxInputGroup(name: String, inputElement: Node): Node / { HTMLElement } = {
  div {
    inputElement.insert.css {
      property("width", "18px")
      property("height", "18px")
      property("cursor", "pointer")
      property("box-sizing", "border-box")
    }.attributes {
      attribute("id", name)
    }

    label(name).css {
      property("font-size", "0.85rem")
      property("font-weight", "600")
      property("color", "#a6adc8")
      property("cursor", "pointer")
    }.attributes {
      attribute("for", name)
    }
    
  }.css {
    property("display", "flex")
    property("align-items", "center")
    property("cursor", "pointer")
    property("user-select", "none")
    property("gap", "10px")
    property("box-sizing", "border-box")
  }
  return inputElement
}
/// Main page content and layout
/// Creates all the input elements and the main div to draw into
/// see flexbox docu: https://css-tricks.com/snippets/css/a-guide-to-flexbox/
def createPageContent(body: Node): Unit = {
  with body.onChildren

  val color      = createElement("input")
  val mask       = createElement("input")
  val size       = createElement("input")
  val gridSize   = createElement("input")
  val speed      = createElement("input")
  val draw       = createElement("input")
  val save       = createElement("input")
  var runButton  = createElement("button")

  

  "aside".create.children {
    div {
      div {
        h2("Effektive Blocks").css {
          property("margin", "0")
          property("font-size", "1.4rem")
          property("color", "#9fb8c4ff")
        }
        small("Wave Function Collapse in Effekt")
      }

      button() {
        text "Help"
      }.css {
        property("background", "none")
        property("border", "1px solid #74c7ec")
        property("color", "#b8e6fbff")
        property("border-radius", "4px")
        property("padding", "2px 8px")
        property("cursor", "pointer")
        property("font-size", "0.75rem")
      }.onClick(box {
        showAlert("""
          Quick Help

          > Tileset: 
          Image with all tiles in a grid (e.g. 4x6).

          > Ruleset: 
          Image defining tile adjacencies. Must match Tileset aspect ratio. 

          > Pixels per Tile: 
          The width/height of each tile in the tileset (e.g. 32).

          > Grid Dimensions: 
          World size to generate.

          > Speed: 
          Frequency of automatic generation.

          > Manual Mode: 
          If enabled, you click cells to collapse them yourself.`
        """)
      })

    }.css {
      property("justify-content", "space-between")
      property("align-items", "center")
      property("display", "flex")
      property("margin-bottom", "10px")
      property("padding-bottom", "10px")
      property("border-bottom", "1px solid #45475a")
    }
    addInputGroup("Tileset", color).attributes {
      attribute("type", "file")
      attribute("accept", "image/*")
    }
    addInputGroup("Ruleset", mask).attributes {
      attribute("type", "file")
      attribute("accept", "image/*")
    }
    addInputGroup("Pixels per Tile", size).attributes {
      attribute("type", "number")
      attribute("step", "1")
      attribute("value", "8")
      attribute("min", "1")
      attribute("max", "1024")
    }
    addInputGroup("Grid Dimension", gridSize).attributes {
      attribute("type", "number")
      attribute("type", "number")
      attribute("step", "1")
      attribute("value", "8")
      attribute("min", "1")
      attribute("max", "256")
    }
    addInputGroup("Speed", speed).attributes {
      attribute("type", "range")
      attribute("value", "90")
      attribute("min", "0")
      attribute("max", "100")
    }.css {
      property("padding", "5px 0")
      property("cursor", "pointer")
    }
    addCheckboxInputGroup("Automatic", draw).attributes {
      attribute("type", "checkbox")
      attribute("checked", "false")
    }
    addCheckboxInputGroup("Download", save).attributes {
      attribute("type", "checkbox")
      attribute("checked", "false")
    }
    runButton.insert
    .children {
      text"Calculate"
    }.css {
      property("margin-top", "10px")
      property("background-color", "#9bbbcaff")
      property("color", "#11111b")
      property("border", "none")
      property("padding", "12px")
      property("font-weight", "bold")
      property("font-size", "1rem")
      property("border-radius", "6px")
      property("cursor", "pointer")
      property("transition", "background-color 0.2s")
    }
  }.css {
    property("width", "250px")
    property("height", "100%")
    property("background-color", "#1e1e2e")
    property("color", "white")
    property("padding-left", "20px")
    property("padding-right", "20px")
    property("padding-top", "20px")
    property("flex-shrink", "0")
    property("border-right", "2px solid #45475a")
    property("display", "flex")
    property("flex-direction", "column")
    property("gap", "15px")
    property("overflow-y", "auto")
    property("color", "#cdd6f4")
  }
  val drawContainer = div {}.css {
    property("flex-grow", "1")
    property("height", "100%")
    property("display", "flex")
    property("align-items", "center")
    property("justify-content", "center")
    property("background-color", Color(250, 247, 227, 255))
  }
  // Make a unique reference to control the running state, as this cannot be captured directly in the handler
  // Mainly done for performance reasons to avoid recreating the entire state.
  // Can be improved and generalized, but there is no need for it, as this is only done once.
  val p = ref[Ref[Bool]](ref[Bool](true))
  runButton.onClick(box {
    p.get().set(false) // set the old context to stop

    val newRef = ref[Bool](true)
    p.set(newRef)
    def canContinue() : Bool = newRef.get()

    createWFCContext(drawContainer, color, mask, size, gridSize, speed, draw, save, box canContinue)
  })

  ()
}


def main(): Unit = {
  dom::setupPopupHook()

  // Setup background styling
  val documentElement = getDocumentElement()
  val documentBody = getDocumentBody()
  documentElement.css {
    property("background", Color(250, 247, 227, 255))
  }
  Styling::fullscreen(documentElement)
  Styling::fullscreen(documentBody)


  // create a main app container
  with documentBody.onChildren

  val app = getElementById("app").getOrElse {
    val div = div {}
    .attributes {
      attribute("id", "app")
    }
    div
  }
  Styling::fullscreen(app)
  createPageContent(app)

  
  ()
}