module main // must be named same as the file!


// import src/lib/color

import src/lib/dom
import src/lib/canvas
import src/lib/color

import src/wfc/adjacency
import src/wfc/wfc2
import src/wfc/tile

namespace Styling {
  def cell(node: Node) = node.css {
    property("border", "1px solid #ccccccff")
    property("box-sizing", "border-box")
    property("aspect-ratio", "1 / 1")
    property("position", "relative")
    
    property("display", "flex")
    property("align-items", "center")
    property("justify-content", "center")
  }

  def grid(node: Node, size: Int) = node.css {
    property("border", "2px solid #333333ff")
    property("display", "grid")
    property("grid-template-columns", s"repeat(${size.show}, 1fr)")
    property("grid-template-rows", s"repeat(${size.show}, 1fr)")
    property("box-sizing", "border-box")

    property("position", "absolute")
    property("top", "50%")
    property("left", "50%")
    property("transform", "translate(-50%, -50%)")
    property("width", "50vw")
    property("aspect-ratio", "1 / 1")
    property("z-index", 10)
  }

  def fullscreen(node: Node) = node.css {
      property("margin", 0)
      property("padding", 0)
      property("overflow", "hidden")
  }

  def stateCell(node: Node, cellSize: Double, column: Int, row: Int) = node.css {
    property("position", "absolute")
    property("width", cellSize.show ++ "px")
    property("height", cellSize.show ++ "px")
    property("left", (row.toDouble * cellSize).show ++ "px")
    property("top", (column.toDouble * cellSize).show ++ "px")
  }

}


// Create a grid of DOM elements to render the WFC state into
// Each cell can contain multiple images when in manual mode
def createDOMCells(showCanvas: Node, size: Int): Array[Node] = {
  val elements = array::unsafeAllocate(size * size)
  showCanvas.removeContent()
  showCanvas.onChildren {
    val element = div {
      each (0, size) { y =>
        each (0, size) { x =>
          val c = div{}
          Styling::cell(c)
          elements.set(y * size + x, c)
          ()
        }
      }
    };
    Styling::grid(element, size)

    ()
  }
  elements
}



// update the WFC and render the current state. Either done automatically or manually via clicks
def render(manualMode: Bool, delay: Int, images: Array[Node], gridReference: Ref[StateGrid]): Unit = {
  val grid = gridReference.get()
  var size = grid.size
  
  each (0, size) { y =>
    each (0, size) { x =>
      if (manualMode) {
        var imgs = grid.tilesAt((x, y))
       
        var container = images.get(y * size + x)
        var count = imgs.size().toDouble
        val n = count.sqrt().ceil() // calculate size of grid in grid cell
        val size = container.clientWidth.toDouble;   
        val cellSize = size / n.toDouble;   

        container.removeContent()
        imgs.foreachIndex { (i, tileIndex) => {
          var img = grid.tileset.tiles.get(tileIndex).htmlImage
          val item = img.clone; // clone image element
          val column = (i.toDouble / n.toDouble).floor;
          val row = (i.mod(n));
          Styling::stateCell(item, cellSize, column, row)

          //setup click handler to collapse cells
          item.onClick(box {
            with popup
            try {
              grid.collapseAtSpecific((x, y), tileIndex)
              grid.propagate((x, y))
              render(manualMode, delay, images, gridReference)
            } with fail { => 
              do Popup("Could not solve image, try increasing the size or changing the image/mask")
            } with stop { => 
            // solved, do nothing
            }
          })
          container.appendChild(item)
          ()
        }}
      } else {
        var imgs = grid.getImages((x, y))
        if (imgs.size() == 1) {
          // collapse into a single image
          var container = images.get(y * size + x)
          container.removeContent()
          container.appendChild(imgs.get(0).clone)
        }
      }
      ()
    }
  }

  if (not(manualMode)) {
    dom::wait(delay, box {
      with popup
      try {
        grid.step()
        render(manualMode, delay, images, gridReference)
      } with fail { => 
        do Popup("Could not solve image, try increasing the size or changing the image/mask")
      } with stop { => 
        // solved, do nothing
      }
      ()
    })
  }
}

// Note that this does all the error handling. 
// Errors are handled each click, so the user can try again without reloading the page.
def createWFCContext(
  showCanvas: Node,     // main canvas to draw to
  color: Node,          // color image
  mask: Node,           // mask image
  size: Node,           // pixels per tile
  gridSizeNode: Node,   // size of the grid
  speedNode: Node,      // speed of the visualization
  drawNode: Node,       // whether to draw the process, or let the use click
  canContinue: => Bool at global
) at {io}: Unit = {

  with popup 

  val pixels       =    size.numberFromInputElement()
  val gridSize     =    gridSizeNode.numberFromInputElement()
  val speedPercent =    speedNode.numberFromInputElement().toDouble / 100.0
  val draw         =    drawNode.boolFromInputElement()

  if (draw && gridSize > 16) {
    do Popup("Size to lange. Your browser does not support this. Disable drawing. ")
  }

  canvas::loadImageFromInputElement(color, box { color? => 
    canvas::loadImageFromInputElement(mask, box { mask? => 
      with popup

      val color: Image = color?.getOrElse {
        do Popup(s"Provide a color image")
      }
      val mask: Image = mask?.getOrElse {
        do Popup(s"Provide a mask image")
      }
      // first the layout of the color and mask image
      val imageLayout = createLayout(color, mask, pixels)
      // calculate ruleset from image data 
      val ruleset = createRuleset(color, mask, imageLayout)

      // calculate tileset to draw and work with
      val tileset = ruleset.calculateTileSet()

      val state = ref(wfcStateGrid(tileset, gridSize))

      //calculate the speed
      val maxWait = 1000
      val waitTime = (maxWait.toDouble * (1.0 - speedPercent)).max(0.0).toInt

      var imgs = createDOMCells(showCanvas, gridSize)
      render(draw, waitTime, imgs, state)

      ()
    })
  })

}


// Main page content and layout
// see flexbox docu: https://css-tricks.com/snippets/css/a-guide-to-flexbox/
def createPageContent(app: Node): Unit = {
  with app.onChildren

  val drawContainer = div {} // grid container

  val color     = createElement("input")
  val mask      = createElement("input")
  val size      = createElement("input")
  val gridSize  = createElement("input")
  val speed     = createElement("input")
  val draw      = createElement("input")
  var runButton = createElement("button")

  // Make a unique reference to control the running state, as this cannot be captured directly in the handler
  // Mainly done for performance reasons to avoid recreating the entire state.
  // Can be improved and generalized, but there is no need for it, as this is only done once.
  val p = ref[Ref[Bool]](ref[Bool](true))
  runButton.onClick(box {
    p.get().set(false) // set the old context to stop

    val newRef = ref[Bool](true)
    p.set(newRef)
    def canContinue() : Bool = newRef.get()

    createWFCContext(drawContainer, color, mask, size, gridSize, speed, draw, box canContinue)
  })

  row {
    column {
      row {
        text"Image "
        color.insert
        .attributes {
          attribute("type", "file")
          attribute("accept", "image/*")
        }
      }
      row {
        text"Mask "
        mask.insert
        .attributes {
          attribute("type", "file")
          attribute("accept", "image/*")
        }
      }
      row {
        text"Pixels per Tile "
        row {
          size.insert
          .attributes {
            attribute("type", "number")
            attribute("step", "1")
            attribute("value", "8")
            attribute("min", "1")
            attribute("max", "1024")
          }.css {
            property("flex-basis", "40%")
          }
        }.css {
          property("justify-content", "space-between")
          property("margin-left", "20px")
        }
      }
      row {
        text"Grid size "
        row {
          gridSize.insert
          .attributes {
            attribute("type", "number")
            attribute("type", "number")
            attribute("step", "1")
            attribute("value", "8")
            attribute("min", "1")
            attribute("max", "256")
          }.css {
            property("flex-basis", "40%")
          }
        }.css {
          property("justify-content", "space-between")
          property("margin-left", "20px")
        }
      }

      row {
        text"Speed "
        row {
          speed.insert
          .attributes {
            attribute("type", "range")
            attribute("value", "90")
            attribute("min", "0")
            attribute("max", "100")
          }.css {
            property("flex-basis", "40%")
          }
        }.css {
          property("justify-content", "space-between")
          property("margin-left", "20px")
        }
      }
      row {
        text"Automatic? "
        row {
          draw.insert
          .attributes {
            attribute("type", "checkbox")
            attribute("checked", "true")
          }.css {
            property("flex-basis", "40%")
          }
        }.css {
          property("justify-content", "space-between")
          property("margin-left", "20px")
        }
      }
      runButton.insert
      .children {
        text"Calculate"
      }
    }.css {
      property("width", "20%")
    }
  }
  ()
}


def main(): Unit = {
  dom::setupPopupHook()

  // Setup background styling
  val documentElement = getDocumentElement()
  val documentBody = getDocumentBody()
  documentElement.css {
    property("background", Color(250, 247, 227, 255))
  }
  Styling::fullscreen(documentElement)
  Styling::fullscreen(documentBody)


  // create a main app container
  with documentBody.onChildren

  val appDiv = getElementById("app").getOrElse {
    val div = div {}
    .attributes {
      attribute("id", "app")
    }
    div
  }

  createPageContent(appDiv)

  
  ()
}