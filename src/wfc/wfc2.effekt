module wfc2

/*
 Advanced Wave Function Collapse implementation
 This implementation uses constraint propagation to efficiently find a valid tiling.
 See wfc1 for a more naive implementation using backtracking search.
*/

import src/wfc/tile
import src/lib/array
import src/lib/canvas
import src/lib/color


effect fail(): Nothing // Used for constraint failures (when WFC gets stuck)

record StateGrid(tileset: TileSet, size: Int, cells: Array[Array[Array[TileIndex]]])



def offset(coords: Vec2I, direction: Direction): Vec2I = {
  val (x, y) = coords
  (x + direction.dx, y + direction.dy)
}




def infixEq(a: Vec2I, b: Vec2I): Bool = 
  a.first == b.first && a.second == b.second

def foreachCell(self: StateGrid) { coords: Vec2I => Unit }: Unit = {
  self.cells.foreachIndex { (x, c) =>
    c.foreachIndex { (y, tiles) => 
      coords((x, y))
    }
  }
}

// find cell with lowest number of prototypes (Entropy). When none found, return None
def getMinEntropyCoords(self: StateGrid): Option[Vec2I] = {
  var best = Nil()
  var lowestEntropy = 1000000

  self.foreachCell { coords => 
      val tiles = self.tilesAt(coords)
      var entropy = tiles.size
      if (entropy != 1) {
        if (entropy == lowestEntropy) {
          best = Cons(coords, best)
        } else if (entropy < lowestEntropy) {
          lowestEntropy = entropy
          best = Cons(coords, Nil())
        }
      }
  }
  // shuffle to get random values each time
  arrays::pickRandom(array::fromList(best))
}

def collapseAt(self: StateGrid, coords: Vec2I): Unit = {
  val tiles = self.tilesAt(coords)
  arrays::pickRandom(tiles) match {
    // removes all element from the list 
    // and adds the element, so it only contains this element. In place! (important!)
    case Some(v) => arrays::setToOne(tiles, v)
    case None() => {
      panic("got no tiles at " ++ coords.show)   
    }
  }
}


def neighbors(self: StateGrid, coords: Vec2I) { coord: (Vec2I, Direction) => Unit }: Unit = {
  Direction::VALUES.foreach { dir => 
    val offset = coords.offset(dir)
    val (x, y) = offset
    if (x >= 0 && y >= 0 && x < self.size && y < self.size) {
      coord(offset, dir)
    }
  }
}

def tilesAt(self: StateGrid, coords: Vec2I): Array[TileIndex] = {
  val (x, y) = coords
  return self.cells.get(x).get(y)
}

def allNeigbors(self: StateGrid, coords: Vec2I, dir: Direction): Array[TileIndex] = {
  var list = Nil()

  self.tilesAt(coords).foreach { tileIndex => 
    val tile = self.tileset.tiles.get(tileIndex)
    tile.adjacencyOfDirection(dir).foreach { n => 
      list = Cons(n , list)
    }
    ()
  }
  list.fromList.unique
}

def constrain(self: StateGrid, coords: Vec2I, index: TileIndex): Unit / fail = {
  val toReduce = self.tilesAt(coords)
  if (toReduce.size == 1 || toReduce.size == 0) {
    do fail()
  }

  arrays::remove(toReduce, index)
}


def propagate(self: StateGrid, coords: Vec2I): Unit / fail = {
  var stack = array::array(1, (0, 0))
  stack.push(coords)

  with boundary
  while (true) {
    var element = stack.pop() match {
      case Some(s) => s
      case None() => do stop()
    }
    
    self.neighbors(element) { (neighborCoords, direction) =>
      var neighborTiles = arrays::copy(self.tilesAt(neighborCoords))
      var currentNeighborsByDir = self.allNeigbors(element, direction)

      neighborTiles.foreach { neighborTile =>
        val possible? = arrays::contains(currentNeighborsByDir, neighborTile) 
        if (not(possible?)) {
          self.constrain(neighborCoords, neighborTile)
          // stack = stack.push_back_unique(neighborCoords)
          if (not(stack.contains(neighborCoords))) {
            stack.push(neighborCoords)
          }
        }
      }
      
    }
  }
}


/*
  interface
*/ 

// create a new fully open state grid
def wfcStateGrid(tileset: TileSet, size: Int): StateGrid = {
  var numbers = array::build(tileset.tiles.size) { i => i }

  val cells = array::build(size) { _ =>
    array::build(size) { _ => 
      arrays::copy(numbers)
    }
  }
  StateGrid(tileset, size, cells)
}


// collapse cell at coords to specific element, should be valid (has to be checked before)
def collapseAtSpecific(self: StateGrid, coords: Vec2I, element: TileIndex): Unit = {
  val tiles = self.tilesAt(coords)
  arrays::setToOne(tiles, element)
}

// perform one iteration at coords: collapse + propagate
def iterateAt(grid: StateGrid, coords: Vec2I): Unit / fail = {
  grid.collapseAt(coords)
  grid.propagate(coords)
}

// perform one step of the WFC algorithm, i.e. find cell with lowest entropy, collapse and propagate
def step(grid: StateGrid) at {global, io}: Unit / {stop, fail} = {
  if (grid.getMinEntropyCoords() is Some(coords)) {
    grid.iterateAt(coords)
  } else {
    do stop()
  }
}
// solve the WFC grid completely
def solve(grid: StateGrid): Unit / fail = {
  while (grid.getMinEntropyCoords() is Some(coords)) {
    grid.iterateAt(coords)
  }
}


// get all the DOM images for the tiles at coords
def getImages(grid: StateGrid, coords: Vec2I) at {io, global}: Array[Node] = {
  val tiles = grid.tilesAt(coords)
  tiles.mapped { i => 
    grid.tileset.tiles.get(i).htmlImage
  }
}

// Debug for showing all the images of a grid
def createDebugStateImage(grid: StateGrid, tileCount: Int) at {io, global}: Image = {
  val tileSize = grid.tileset.tiles.get(0).image.width
  var canvasSize = grid.size * tileCount * tileSize;
  val ctx = context2D(canvasSize, canvasSize)
  
  ctx.draw {
    grid.foreachCell { (coords) =>
      val (cellX, cellY) = coords
      val tiles = grid.tilesAt(coords)
      tiles.size match {
        case -1 => {
          val i = tiles.get(0)
          val tileImage = grid.tileset.tiles.get(i).image
          var totalX = cellX * tileCount
          var totalY = cellY * tileCount
          do image(tileImage.scale(tileCount), totalX * tileSize, totalY * tileSize)
          ()
        }
        case _ => {
          tiles.foreach { i =>  
            val tileImage = grid.tileset.tiles.get(i).image
            val tileX = i.mod(tileCount)
            val tileY = i / tileCount
            var totalX = cellX * tileCount + tileX
            var totalY = cellY * tileCount + tileY

            do image(tileImage, totalX * tileSize, totalY * tileSize)
          }
        }
      }
      
      ()
    }
  }

  ctx.image(canvasSize, canvasSize)
}

// Debug for showing only the collapsed cells of a grid
def createDebugStateImageCollapsed(grid: StateGrid) at {io, global}: Image = {
  val tileSize = grid.tileset.tiles.get(0).image.width
  var canvasSize = grid.size * tileSize;
  val ctx = context2D(canvasSize, canvasSize)
  
  ctx.draw {
    grid.foreachCell { (coords) =>
      val (cellX, cellY) = coords
      val tiles = grid.tilesAt(coords)
      if (tiles.size == 1) {
        val i = tiles.get(0)
        val tileImage = grid.tileset.tiles.get(i).image
        do image(tileImage, cellX * tileSize, cellY * tileSize)
      }
    }
  }

  ctx.image(canvasSize, canvasSize)
}
